// Code generated by protoc-gen-ext. DO NOT EDIT.
// source: tests/api/hello.proto

package api

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"strings"

	"github.com/solo-io/protoc-gen-ext/pkg/clone"
	"google.golang.org/protobuf/proto"
)

// ensure the imports are used
var (
	_ = errors.New("")
	_ = fmt.Print
	_ = binary.LittleEndian
	_ = bytes.Compare
	_ = strings.Compare
	_ = clone.Cloner(nil)
	_ = proto.Message(nil)
)

// Clone function
func (m *Simple) Clone() proto.Message {
	if m == nil {
		return nil
	}
	target := &Simple{}

	target.Str = m.GetStr()

	target.Byt = make([]byte, len(m.GetByt()))
	copy(target.Byt, m.GetByt())

	target.TestUint32 = m.GetTestUint32()

	target.TestUint64 = m.GetTestUint64()

	target.TestBool = m.GetTestBool()

	target.DoubleTest = m.GetDoubleTest()

	target.FloatTest = m.GetFloatTest()

	target.Int32Test = m.GetInt32Test()

	target.Int64Test = m.GetInt64Test()

	target.Sint32Test = m.GetSint32Test()

	target.Sint64Test = m.GetSint64Test()

	target.Fixed32Test = m.GetFixed32Test()

	target.Fixed64Test = m.GetFixed64Test()

	target.Sfixed32Test = m.GetSfixed32Test()

	target.Sfixed64Test = m.GetSfixed64Test()

	target.StrSkipped = m.GetStrSkipped()

	target.IntSkipped = m.GetIntSkipped()

	return target
}

// Clone function
func (m *Nested) Clone() proto.Message {
	if m == nil {
		return nil
	}
	target := &Nested{}

	if h, ok := interface{}(m.GetSimple()).(clone.Cloner); ok {
		target.Simple = h.Clone().(*Simple)
	} else {
		target.Simple = proto.Clone(m.GetSimple()).(*Simple)
	}

	if h, ok := interface{}(m.GetOtherSimple()).(clone.Cloner); ok {
		target.OtherSimple = h.Clone().(*Simple)
	} else {
		target.OtherSimple = proto.Clone(m.GetOtherSimple()).(*Simple)
	}

	target.Test = m.GetTest()

	if h, ok := interface{}(m.GetEmpty()).(clone.Cloner); ok {
		target.Empty = h.Clone().(*Empty)
	} else {
		target.Empty = proto.Clone(m.GetEmpty()).(*Empty)
	}

	for idx, v := range m.GetHello() {

		target.Hello[idx] = v

	}

	if h, ok := interface{}(m.GetDetails()).(clone.Cloner); ok {
		target.Details = h.Clone().(*structpb.Struct)
	} else {
		target.Details = proto.Clone(m.GetDetails()).(*structpb.Struct)
	}

	if h, ok := interface{}(m.GetSkipper()).(clone.Cloner); ok {
		target.Skipper = h.Clone().(*Simple)
	} else {
		target.Skipper = proto.Clone(m.GetSkipper()).(*Simple)
	}

	for idx, v := range m.GetX() {

		if h, ok := interface{}(v).(clone.Cloner); ok {
			target.X[idx] = h.Clone().(*Simple)
		} else {
			target.X[idx] = proto.Clone(v).(*Simple)
		}

	}

	for k, v := range m.GetInitial() {

		if h, ok := interface{}(v).(clone.Cloner); ok {
			target.Initial[k] = h.Clone().(*Simple)
		} else {
			target.Initial[k] = proto.Clone(v).(*Simple)
		}

	}

	for k, v := range m.GetSimpleMap() {

		target.SimpleMap[k] = v

	}

	for idx, v := range m.GetRepeatedPrimitive() {

		target.RepeatedPrimitive[idx] = v

	}

	switch m.TestOneOf.(type) {

	case *Nested_EmptyOneOf:

		if h, ok := interface{}(m.GetEmptyOneOf()).(clone.Cloner); ok {
			target.TestOneOf = &Nested_EmptyOneOf{
				EmptyOneOf: h.Clone().(*Empty),
			}
		} else {
			target.TestOneOf = &Nested_EmptyOneOf{
				EmptyOneOf: proto.Clone(m.GetEmptyOneOf()).(*Empty),
			}
		}

	case *Nested_NestedOneOf:

		if h, ok := interface{}(m.GetNestedOneOf()).(clone.Cloner); ok {
			target.TestOneOf = &Nested_NestedOneOf{
				NestedOneOf: h.Clone().(*NestedEmpty),
			}
		} else {
			target.TestOneOf = &Nested_NestedOneOf{
				NestedOneOf: proto.Clone(m.GetNestedOneOf()).(*NestedEmpty),
			}
		}

	case *Nested_PrimitiveOneOf:

		target.TestOneOf = &Nested_PrimitiveOneOf{
			PrimitiveOneOf: m.GetPrimitiveOneOf(),
		}

	case *Nested_BytesOneOf:

		{
			newArr := make([]byte, len(m.GetBytesOneOf()))
			copy(newArr, m.GetBytesOneOf())
			target.TestOneOf = &Nested_BytesOneOf{
				BytesOneOf: newArr,
			}
		}

	}

	return target
}

// Clone function
func (m *Empty) Clone() proto.Message {
	if m == nil {
		return nil
	}
	target := &Empty{}

	return target
}

// Clone function
func (m *NestedEmpty) Clone() proto.Message {
	if m == nil {
		return nil
	}
	target := &NestedEmpty{}

	if h, ok := interface{}(m.GetNested()).(clone.Cloner); ok {
		target.Nested = h.Clone().(*Nested)
	} else {
		target.Nested = proto.Clone(m.GetNested()).(*Nested)
	}

	return target
}
