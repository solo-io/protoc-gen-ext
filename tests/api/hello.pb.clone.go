// Code generated by protoc-gen-ext. DO NOT EDIT.
// source: tests/api/hello.proto

package api

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"strings"

	gogo_proto "github.com/gogo/protobuf/proto"
	"github.com/solo-io/protoc-gen-ext/pkg/clone"
	"google.golang.org/protobuf/proto"

	github_com_golang_protobuf_ptypes_struct "github.com/golang/protobuf/ptypes/struct"
)

// ensure the imports are used
var (
	_ = errors.New("")
	_ = fmt.Print
	_ = binary.LittleEndian
	_ = bytes.Compare
	_ = strings.Compare
	_ = clone.Cloner(nil)
	_ = proto.Message(nil)
	_ = gogo_proto.Message(nil)
)

// Clone function
func (m *Simple) Clone() proto.Message {
	var target *Simple
	if m == nil {
		return target
	}
	target = &Simple{}

	target.Str = m.GetStr()

	if m.GetByt() != nil {
		target.Byt = make([]byte, len(m.GetByt()))
		copy(target.Byt, m.GetByt())
	}

	target.TestUint32 = m.GetTestUint32()

	target.TestUint64 = m.GetTestUint64()

	target.TestBool = m.GetTestBool()

	target.DoubleTest = m.GetDoubleTest()

	target.FloatTest = m.GetFloatTest()

	target.Int32Test = m.GetInt32Test()

	target.Int64Test = m.GetInt64Test()

	target.Sint32Test = m.GetSint32Test()

	target.Sint64Test = m.GetSint64Test()

	target.Fixed32Test = m.GetFixed32Test()

	target.Fixed64Test = m.GetFixed64Test()

	target.Sfixed32Test = m.GetSfixed32Test()

	target.Sfixed64Test = m.GetSfixed64Test()

	target.StrSkipped = m.GetStrSkipped()

	target.IntSkipped = m.GetIntSkipped()

	return target
}

// Clone function
func (m *Nested) Clone() proto.Message {
	var target *Nested
	if m == nil {
		return target
	}
	target = &Nested{}

	if h, ok := interface{}(m.GetSimple()).(clone.Cloner); ok {
		target.Simple = h.Clone().(*Simple)
	} else {
		target.Simple = proto.Clone(m.GetSimple()).(*Simple)
	}

	if h, ok := interface{}(m.GetOtherSimple()).(clone.Cloner); ok {
		target.OtherSimple = h.Clone().(*Simple)
	} else {
		target.OtherSimple = proto.Clone(m.GetOtherSimple()).(*Simple)
	}

	target.Test = m.GetTest()

	if h, ok := interface{}(m.GetEmpty()).(clone.Cloner); ok {
		target.Empty = h.Clone().(*Empty)
	} else {
		target.Empty = proto.Clone(m.GetEmpty()).(*Empty)
	}

	if m.GetHello() != nil {
		target.Hello = make([]string, len(m.GetHello()))
		for idx, v := range m.GetHello() {

			target.Hello[idx] = v

		}
	}

	if h, ok := interface{}(m.GetDetails()).(clone.Cloner); ok {
		target.Details = h.Clone().(*github_com_golang_protobuf_ptypes_struct.Struct)
	} else {
		target.Details = proto.Clone(m.GetDetails()).(*github_com_golang_protobuf_ptypes_struct.Struct)
	}

	if h, ok := interface{}(m.GetSkipper()).(clone.Cloner); ok {
		target.Skipper = h.Clone().(*Simple)
	} else {
		target.Skipper = proto.Clone(m.GetSkipper()).(*Simple)
	}

	if m.GetX() != nil {
		target.X = make([]*Simple, len(m.GetX()))
		for idx, v := range m.GetX() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.X[idx] = h.Clone().(*Simple)
			} else {
				target.X[idx] = proto.Clone(v).(*Simple)
			}

		}
	}

	if m.GetInitial() != nil {
		target.Initial = make(map[string]*Simple, len(m.GetInitial()))
		for k, v := range m.GetInitial() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.Initial[k] = h.Clone().(*Simple)
			} else {
				target.Initial[k] = proto.Clone(v).(*Simple)
			}

		}
	}

	if m.GetSimpleMap() != nil {
		target.SimpleMap = make(map[string]string, len(m.GetSimpleMap()))
		for k, v := range m.GetSimpleMap() {

			target.SimpleMap[k] = v

		}
	}

	if m.GetRepeatedPrimitive() != nil {
		target.RepeatedPrimitive = make([]uint64, len(m.GetRepeatedPrimitive()))
		for idx, v := range m.GetRepeatedPrimitive() {

			target.RepeatedPrimitive[idx] = v

		}
	}

	if m.GetRepeatedExternal() != nil {
		target.RepeatedExternal = make([]*github_com_golang_protobuf_ptypes_struct.Struct, len(m.GetRepeatedExternal()))
		for idx, v := range m.GetRepeatedExternal() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.RepeatedExternal[idx] = h.Clone().(*github_com_golang_protobuf_ptypes_struct.Struct)
			} else {
				target.RepeatedExternal[idx] = proto.Clone(v).(*github_com_golang_protobuf_ptypes_struct.Struct)
			}

		}
	}

	if m.GetMapExternal() != nil {
		target.MapExternal = make(map[string]*github_com_golang_protobuf_ptypes_struct.Struct, len(m.GetMapExternal()))
		for k, v := range m.GetMapExternal() {

			if h, ok := interface{}(v).(clone.Cloner); ok {
				target.MapExternal[k] = h.Clone().(*github_com_golang_protobuf_ptypes_struct.Struct)
			} else {
				target.MapExternal[k] = proto.Clone(v).(*github_com_golang_protobuf_ptypes_struct.Struct)
			}

		}
	}

	if h, ok := interface{}(m.GetGogoField()).(clone.Cloner); ok {
		target.GogoField = h.Clone().(*github_com_golang_protobuf_ptypes_struct.Struct)
	} else {
		target.GogoField = gogo_proto.Clone(m.GetGogoField()).(*github_com_golang_protobuf_ptypes_struct.Struct)
	}

	switch m.TestOneOf.(type) {

	case *Nested_EmptyOneOf:

		if h, ok := interface{}(m.GetEmptyOneOf()).(clone.Cloner); ok {
			target.TestOneOf = &Nested_EmptyOneOf{
				EmptyOneOf: h.Clone().(*Empty),
			}
		} else {
			target.TestOneOf = &Nested_EmptyOneOf{
				EmptyOneOf: proto.Clone(m.GetEmptyOneOf()).(*Empty),
			}
		}

	case *Nested_NestedOneOf:

		if h, ok := interface{}(m.GetNestedOneOf()).(clone.Cloner); ok {
			target.TestOneOf = &Nested_NestedOneOf{
				NestedOneOf: h.Clone().(*NestedEmpty),
			}
		} else {
			target.TestOneOf = &Nested_NestedOneOf{
				NestedOneOf: proto.Clone(m.GetNestedOneOf()).(*NestedEmpty),
			}
		}

	case *Nested_PrimitiveOneOf:

		target.TestOneOf = &Nested_PrimitiveOneOf{
			PrimitiveOneOf: m.GetPrimitiveOneOf(),
		}

	case *Nested_BytesOneOf:

		if m.GetBytesOneOf() != nil {
			newArr := make([]byte, len(m.GetBytesOneOf()))
			copy(newArr, m.GetBytesOneOf())
			target.TestOneOf = &Nested_BytesOneOf{
				BytesOneOf: newArr,
			}
		} else {
			target.TestOneOf = &Nested_BytesOneOf{
				BytesOneOf: nil,
			}
		}

	}

	return target
}

// Clone function
func (m *Empty) Clone() proto.Message {
	var target *Empty
	if m == nil {
		return target
	}
	target = &Empty{}

	return target
}

// Clone function
func (m *NestedEmpty) Clone() proto.Message {
	var target *NestedEmpty
	if m == nil {
		return target
	}
	target = &NestedEmpty{}

	if h, ok := interface{}(m.GetNested()).(clone.Cloner); ok {
		target.Nested = h.Clone().(*Nested)
	} else {
		target.Nested = proto.Clone(m.GetNested()).(*Nested)
	}

	return target
}
